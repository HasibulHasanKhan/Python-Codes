A — Asynchronous Programming

async/await syntax

asyncio library

Event loops, coroutines, tasks, futures

Concurrency vs parallelism

Using aiohttp, aiomysql, asyncpg

B — Built-in Functions & Advanced Usage

Deep dive into map(), filter(), zip(), enumerate()

all(), any(), sorted() with key functions

eval() and exec() (with caution)

globals() and locals()

C — Concurrency & Parallelism

threading vs multiprocessing

Global Interpreter Lock (GIL)

concurrent.futures (ThreadPoolExecutor, ProcessPoolExecutor)

joblib, dask for parallel computing

D — Data Handling

Advanced pandas and numpy

Working with large datasets efficiently

pickle, marshal, shelve for object serialization

h5py, pyarrow for big data

E — Error Handling & Exceptions

Custom exceptions

Exception chaining (raise ... from ...)

Context managers for safe cleanup

Logging best practices

F — Functional Programming

lambda, map, reduce, filter

Closures, decorators, higher-order functions

functools (partial, lru_cache, wraps)

Immutability & functional patterns

G — Generators & Iterators

yield & yield from

Generator expressions

Custom iterators with __iter__ & __next__

Lazy evaluation

H — High-performance Python

Profiling (cProfile, timeit, line_profiler)

Memory optimization (tracemalloc, gc)

Cython, Numba for speedups

Multiprocessing vs asyncio for performance

I — Introspection & Reflection

dir(), getattr(), setattr(), hasattr()

inspect module

Type hints & annotations (typing, mypy)

__dict__, __slots__, __annotations__

J — JSON & Serialization

json module advanced usage

orjson, ujson for fast JSON

Protocol Buffers, Avro, MessagePack

K — Kinds of Imports & Packaging

Absolute vs relative imports

importlib for dynamic imports

Structuring packages & modules

__init__.py usage

Building reusable libraries

L — Logging & Debugging

Logging levels, handlers, formatters

Structured logging (loguru)

Debugging (pdb, ipdb)

Unit testing with pytest

M — Metaprogramming

Decorators (function & class-based)

Metaclasses (type, __new__, __init__)

Monkey patching

Dynamic code execution

N — Networking

socket programming (TCP/UDP)

HTTP requests (requests, httpx)

WebSockets (websockets)

REST API development

O — Object-Oriented Python (Advanced)

Dunder methods (__str__, __repr__, __call__, __getitem__)

@property, setters, deleters

Abstract classes (abc module)

Multiple inheritance & MRO (Method Resolution Order)

Mixins

P — Patterns & Best Practices

Design patterns (Singleton, Factory, Observer, Strategy)

Dependency injection

Clean code practices

SOLID principles in Python

Q — Querying Data

SQLAlchemy ORM

GraphQL with Python

Query optimization techniques

R — Regular Expressions

Advanced regex (lookahead, lookbehind)

re.sub() with functions

Compiled regex for performance

S — Security

Hashing (hashlib, bcrypt)

Encryption (cryptography, PyNaCl)

Secrets management (secrets, keyring)

Secure coding practices

T — Testing

pytest, unittest, doctest

Mocking (unittest.mock)

Test-driven development (TDD)

CI/CD integration

U — Unicode & Encoding

bytes vs str

encode() and decode()

codecs module

Working with multi-language text

V — Virtual Environments & Dependency Management

venv, virtualenv, pipenv

poetry for project packaging

Requirements management

Dependency versioning

W — Web Development

Flask, Django, FastAPI

REST APIs & GraphQL APIs

Middleware & authentication

Async web frameworks

X — XML & Data Formats

xml.etree.ElementTree

lxml for fast XML parsing

YAML (pyyaml, ruamel.yaml)

CSV best practices

Y — Yield & Coroutines (Advanced Use)

Generator pipelines

Coroutine-based workflows

send(), throw(), close() with generators

Z — Zen of Python & Beyond

import this (The Zen of Python)

Writing Pythonic code

Code readability & maintainability

Contributing to open source